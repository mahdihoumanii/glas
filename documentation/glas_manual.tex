\documentclass[11pt,a4paper]{article}

% -----------------------------------------------------------------------------
% Preamble
% -----------------------------------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{cite}

\geometry{margin=2.5cm}
\setlength{\headheight}{14pt}
\addtolength{\topmargin}{-2pt}

\hypersetup{
  colorlinks=true,
  linkcolor=blue!70!black,
  citecolor=green!40!black,
  urlcolor=blue!70!black
}

\lstset{
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{gray!08},
  frame=single,
  framerule=0pt,
  breaklines=true,
  columns=fullflexible,
  keepspaces=true,
  showstringspaces=false,
  keywordstyle=\color{blue!70!black}\bfseries,
  commentstyle=\color{green!40!black}\itshape,
  stringstyle=\color{red!70!black},
  language=bash
}

\pagestyle{fancy}
\fancyhf{}
\rhead{GLAS Manual}
\lhead{\leftmark}
\rfoot{\thepage}

\title{\textbf{GLAS: General Loop Amplitude System}\\[0.4em]
\large A Practical Manual and Tutorial for Automated One-Loop Workflows}

\author{
  M.~Houmani\\
  \small High Energy Physics Group\\
  \small\texttt{mahdi.houmani@email.com}
}
\date{\today}

% -----------------------------------------------------------------------------
% Document
% -----------------------------------------------------------------------------
\begin{document}
\maketitle

\begin{abstract}
\textsc{GLAS} (General Loop Amplitude System) is a workflow orchestrator for perturbative calculations in high-energy physics. It automates and manages the standard one-loop pipeline by integrating established tools for diagram generation, symbolic manipulation, and reduction.
Rather than replacing these tools, \textsc{GLAS} provides a run-based execution model, a reproducible directory layout, parallel driver generation, and a consistent command interface.
This manual focuses on \emph{how to use} \textsc{GLAS} as a tutorial and operational reference: how to run a process end-to-end, where outputs are written, how the stages connect, and how to debug and extend the system. All external packages used by \textsc{GLAS} are cited throughout.
\end{abstract}

\tableofcontents
\newpage

% -----------------------------------------------------------------------------
\section{What GLAS Is (and What It Is Not)}
% -----------------------------------------------------------------------------

\textsc{GLAS} is designed for practitioners who already rely on specialized HEP software and want a robust way to orchestrate complex multi-stage computations.

\subsection*{GLAS is}
\begin{itemize}[leftmargin=1.2em]
  \item A \textbf{workflow orchestrator} and \textbf{run manager} that stitches together multiple external tools.
  \item A \textbf{parallel driver generator} for \textsc{FORM} tasks and a structured logging system.
  \item A \textbf{reproducible execution environment}: each calculation lives in a self-contained run directory.
\end{itemize}

\subsection*{GLAS is not}
\begin{itemize}[leftmargin=1.2em]
  \item A replacement for \textsc{QGRAF} \cite{Nogueira:1991ex}, \textsc{FORM} \cite{Vermaseren:2000nd,Kuipers:2012rf}, \textsc{Mathematica}, or reduction software.
  \item A monolithic symbolic engine: it delegates heavy symbolic work to established packages and focuses on coordination and reproducibility.
\end{itemize}

% -----------------------------------------------------------------------------
\section{External Toolchain and Citations}
% -----------------------------------------------------------------------------

\textsc{GLAS} relies on a standard ecosystem of tools. The exact installation method may differ between machines, but the conceptual dependency graph stays the same.

\subsection{Core toolchain}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{Diagram generation}: \textsc{QGRAF} \cite{Nogueira:1991ex}
  \item \textbf{Symbolic manipulation and code generation}: \textsc{FORM} \cite{Vermaseren:2000nd,Kuipers:2012rf}
  \item \textbf{Topology discovery and integral processing}: \textsc{Mathematica} with \textsc{FeynCalc} \cite{Shtabovenko:2020gxv}
  \item \textbf{IBP reduction}: \textsc{Blade} (Mathematica package) \cite{Blade:software}
  \item \textbf{Finite-field reconstruction and linear relations}: \textsc{FiniteFlow} \cite{Peraro:2019svx,Peraro:2016wsq}
\end{itemize}

\subsection{Algebra backends used by Mathematica scripts}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{Partial fractioning / multivariate rational simplification}: \textsc{MultivariateApart} \cite{MultivariateApart:software}
  \item \textbf{Rational algebra backend}: \textsc{Fermat} \cite{Lewis:Fermat}
  \item \textbf{Gr\"obner basis / polynomial computations}: \textsc{Singular} \cite{DGPS:Singular}
\end{itemize}

\subsection{Optional / environment-dependent}
Depending on your setup, your IBP stage may also integrate with additional tooling (e.g.\ \textsc{Kira}). If present, cite accordingly \cite{Maierhoefer:2017hyi}.

% -----------------------------------------------------------------------------
\section{Architecture Overview}
% -----------------------------------------------------------------------------

\subsection{Run-based workflow}
All computations occur in a \textbf{run directory}:
\begin{lstlisting}
runs/{tag}_{nnnn}/
\end{lstlisting}
A run is a self-contained snapshot of a calculation: inputs, generated drivers, intermediate products, and logs.

\subsection{Key idea: deterministic outputs}
If you re-run a command inside the same run directory, \textsc{GLAS} reads the run metadata and uses the same directory conventions to locate inputs and write outputs.

\subsection{The three-phase pipeline}
\textsc{GLAS} structures the computation into three operational phases:

\begin{enumerate}[leftmargin=1.2em]
  \item \textbf{Generation} (\texttt{generate})\,: create diagrams and prepare a run skeleton using \textsc{QGRAF}.
  \item \textbf{Evaluation} (\texttt{evaluate}, \texttt{contract}, \texttt{uvct})\,: apply rules and build symbolic expressions via \textsc{FORM}.
  \item \textbf{Reduction and simplification} (\texttt{extract topologies}, \texttt{ibp}, \texttt{reduce}, \texttt{micoef}, \texttt{linrels}, \texttt{ratcombine})\,: extract integrals/topologies in Mathematica, run IBP reduction, and simplify coefficients using finite fields.
\end{enumerate}

% -----------------------------------------------------------------------------
\section{Project Layout}
% -----------------------------------------------------------------------------

A typical \textsc{GLAS} installation follows:
\begin{lstlisting}[language={}]
glas.py
glaslib/
resources/
  formlib/procedures/
  diagrams/
mathematica/scripts/
runs/
\end{lstlisting}

A typical run contains:
\begin{lstlisting}[language={}]
runs/{tag}_{nnnn}/
  meta.json
  diagrams/{0l,1l}/
  form/Files/...
  Mathematica/...
  logs/{command}/...
\end{lstlisting}

\subsection{The \texttt{meta.json} contract}
Each run has a \texttt{meta.json} tracking:
\begin{itemize}[leftmargin=1.2em]
  \item process definition (tokens, tag),
  \item diagram counts at each loop order,
  \item kinematic configuration (Mandelstam definition),
  \item job configuration (requested/effective workers),
  \item gluon polarization reference momenta,
  \item number of master integrals discovered after IBP.
\end{itemize}

% -----------------------------------------------------------------------------
\section{Quickstart Tutorial}
% -----------------------------------------------------------------------------

This section is meant to be copy-paste friendly.

\subsection{Important note: the \texttt{qQtT} run already exists}
Your repository already contains a prepared run for the \texttt{qQtT} process inside \texttt{runs/}. That means you can start by attaching to it without generating anything:
\begin{lstlisting}
glas> runs qQtT
glas> use qQtT_0001
\end{lstlisting}
(If the exact suffix differs, use \texttt{runs qQtT} to list available runs and pick the one present in your local checkout.)

\subsection{Standard end-to-end workflow (REPL)}
A typical full sequence looks like:
\begin{lstlisting}
glas> verbose on

# 1) Evaluate amplitudes (tree + one-loop)
glas> evaluate lo --jobs 8
glas> evaluate nlo --jobs 8 --dirac

# 2) Contract: |M0|^2 and 2Re(M0*M1)
glas> contract lo --jobs 4
glas> contract nlo --jobs 4

# 3) UV counterterms (renormalization ingredients)
glas> uvct

# 4) Extract and map loop topologies (Mathematica + FORM formatting stage)
glas> extract topologies

# 5) IBP reduction (Blade + auxiliary algebra backends)
glas> ibp

# 6) Apply reduction rules to contracted expressions
glas> reduce --jobs 4

# 7) Extract master-integral coefficients
glas> micoef --jobs 4

# 8) Find linear relations over finite fields
glas> linrels

# 9) Combine rational functions into a minimal basis
glas> ratcombine
\end{lstlisting}

\subsection{What you should expect after each step}
This is a practical ``sanity checklist'':

\begin{itemize}[leftmargin=1.2em]
  \item \textbf{After \texttt{evaluate}}: amplitude fragments under \texttt{form/Files/Amps/}.
  \item \textbf{After \texttt{contract}}: interference and squared objects under \texttt{form/Files/} (mode-dependent).
  \item \textbf{After \texttt{extract topologies}}: topology mapping outputs and integral rule headers usable by \textsc{FORM}.
  \item \textbf{After \texttt{ibp}}: reduction rule files (Mathematica + FORM headers) per topology.
  \item \textbf{After \texttt{reduce}}: reduced expressions under \texttt{form/Files/Reduced/}.
  \item \textbf{After \texttt{micoef}}: per-master coefficient files under \texttt{Mathematica/Files/MasterCoefficients/}.
  \item \textbf{After \texttt{linrels}/\texttt{ratcombine}}: simplified relations/basis used to compress the final representation.
\end{itemize}

% -----------------------------------------------------------------------------
\section{Commands (Operational Reference)}
% -----------------------------------------------------------------------------

\subsection{Run navigation}
\begin{lstlisting}
glas> runs [tag]
glas> use {tag}            # attach to latest matching
glas> use {tag}_{nnnn}     # attach to a specific run
glas> show
\end{lstlisting}

\subsection{Generation and preparation}
\begin{lstlisting}
glas> generate g g > t t~ --jobs 8
\end{lstlisting}
This initializes a new run and invokes \textsc{QGRAF} \cite{Nogueira:1991ex}. It also prepares \textsc{FORM} driver scaffolding in the run.

\subsection{Evaluation and contraction}
\begin{lstlisting}
glas> evaluate lo  --jobs K
glas> evaluate nlo --jobs K --dirac
glas> contract lo  --jobs K
glas> contract nlo --jobs K
\end{lstlisting}
These steps generate and execute \textsc{FORM} drivers \cite{Vermaseren:2000nd,Kuipers:2012rf}. The \texttt{--dirac} flag enables additional algebraic simplification inside the symbolic stage.

\subsection{Gluon polarization references}
Some contractions require polarization reference momenta for external gluons. \textsc{GLAS} stores these in \texttt{meta.json} and can prompt when missing:
\begin{lstlisting}
glas> setrefs
\end{lstlisting}

\subsection{Topology extraction and IBP}
Topology extraction uses \textsc{Mathematica} + \textsc{FeynCalc} \cite{Shtabovenko:2020gxv} to identify and map loop integrals onto completed topologies:
\begin{lstlisting}
glas> extract topologies
\end{lstlisting}
IBP reduction is performed by \textsc{Blade} \cite{Blade:software}, and uses algebra backends such as \textsc{Fermat} \cite{Lewis:Fermat}, \textsc{Singular} \cite{DGPS:Singular}, and \textsc{MultivariateApart} \cite{MultivariateApart:software} for simplification:
\begin{lstlisting}
glas> ibp
\end{lstlisting}

\subsection{Coefficient extraction and finite-field simplification}
\begin{lstlisting}
glas> reduce --jobs K
glas> micoef --jobs K
glas> linrels
glas> ratcombine
\end{lstlisting}
Linear relations and basis selection are done using \textsc{FiniteFlow} \cite{Peraro:2019svx,Peraro:2016wsq}, which is the standard approach for large-scale rational reconstruction tasks in modern amplitude pipelines.

% -----------------------------------------------------------------------------
\section{Logging, Debugging, and Reproducibility}
% -----------------------------------------------------------------------------

\subsection{Verbose streaming}
\texttt{verbose on} streams subprocess output in real time with informative prefixes (e.g.\ \texttt{[form ...]}, \texttt{[mma ...]}, \texttt{[py ...]}). Regardless of streaming mode, logs are written to \texttt{runs/\{run\}/logs/}.

\subsection{Where to look when something fails}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{FORM failures}: check \texttt{form\_*.stdout.log} and \texttt{form\_*.stderr.log} in the run.
  \item \textbf{Mathematica failures}: check the corresponding \texttt{logs/} stage file and the script output.
  \item \textbf{External tool paths}: confirm your environment variables (e.g.\ \texttt{FERMATPATH}, \texttt{SINGULARPATH}).
\end{itemize}

\subsection{Reproducibility note}
Everything required to reproduce the pipeline (inputs, intermediate products, drivers, metadata) remains in the run directory. This is intentional: it makes post-mortem debugging and result verification straightforward.

% -----------------------------------------------------------------------------
\section{Extending GLAS (Developer Notes)}
% -----------------------------------------------------------------------------

\subsection{Adding a new command}
The recommended pattern is:
\begin{enumerate}[leftmargin=1.2em]
  \item implement the command module under \texttt{glaslib/commands/},
  \item register it in the REPL shell,
  \item ensure it reads/writes \texttt{meta.json} rather than storing state elsewhere,
  \item follow the existing parallel execution pattern to generate drivers and capture logs.
\end{enumerate}

\subsection{Do not hardcode absolute paths}
All paths should be derived from the run context and project root helpers. This is required for portability and reproducibility.

% -----------------------------------------------------------------------------
\section{Acknowledgments}
% -----------------------------------------------------------------------------

This project is built on top of widely-used community tools: \textsc{QGRAF} \cite{Nogueira:1991ex}, \textsc{FORM} \cite{Vermaseren:2000nd,Kuipers:2012rf}, \textsc{FeynCalc} \cite{Shtabovenko:2020gxv}, \textsc{FiniteFlow} \cite{Peraro:2019svx,Peraro:2016wsq}, and algebra systems including \textsc{Fermat} \cite{Lewis:Fermat} and \textsc{Singular} \cite{DGPS:Singular}. We also acknowledge \textsc{MultivariateApart} \cite{MultivariateApart:software} and the IBP reduction tooling (\textsc{Blade}) \cite{Blade:software} used in the reduction stage.

% -----------------------------------------------------------------------------
% Bibliography
% -----------------------------------------------------------------------------
\begin{thebibliography}{99}

\bibitem{Nogueira:1991ex}
P.~Nogueira,
``Automatic Feynman graph generation,''
J.\ Comput.\ Phys.\ \textbf{105} (1993) 279.

\bibitem{Vermaseren:2000nd}
J.~A.~M.~Vermaseren,
``New features of FORM,''
arXiv:math-ph/0010025.

\bibitem{Kuipers:2012rf}
J.~Kuipers, T.~Ueda, J.~A.~M.~Vermaseren and J.~Vollinga,
``FORM version 4.0,''
Comput.\ Phys.\ Commun.\ \textbf{184} (2013) 1453.

\bibitem{Shtabovenko:2020gxv}
V.~Shtabovenko, R.~Mertig and F.~Orellana,
``FeynCalc 9.3: New features and improvements,''
Comput.\ Phys.\ Commun.\ \textbf{256} (2020) 107478.

\bibitem{Peraro:2016wsq}
T.~Peraro,
``Scattering amplitudes over finite fields and multivariate functional reconstruction,''
JHEP \textbf{12} (2016) 030.

\bibitem{Peraro:2019svx}
T.~Peraro,
``FiniteFlow: multivariate functional reconstruction using finite fields and dataflow graphs,''
JHEP \textbf{07} (2019) 031.

\bibitem{Lewis:Fermat}
R.~H.~Lewis,
``Fermat: a computer algebra system for polynomial and matrix computation,''
(Software documentation and distribution).

\bibitem{DGPS:Singular}
W.~Decker, G.-M.~Greuel, G.~Pfister, and H.~Sch\"onemann,
``Singular 4-0-2 --- A computer algebra system for polynomial computations,''
\url{https://www.singular.uni-kl.de}.

\bibitem{MultivariateApart:software}
M.~Heller and A.~von~Manteuffel,
``MultivariateApart --- multivariate partial fraction decomposition,''
(Software documentation and distribution; bundled in this repository).

\bibitem{Blade:software}
``Blade --- IBP reduction package for Mathematica,''
(Software documentation and distribution; used by \textsc{GLAS} in the IBP stage).

\bibitem{Maierhoefer:2017hyi}
P.~Maierh\"ofer, J.~Usovitsch and P.~Uwer,
``Kira --- A Feynman integral reduction program,''
Comput.\ Phys.\ Commun.\ \textbf{230} (2018) 99.

\end{thebibliography}

\end{document}